<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Visual Inference for Graphcial Diagnostic of Linear Mixed Models</title>
    <meta charset="utf-8" />
    <meta name="author" content="Kaiwen Jin" />
    <meta name="date" content="2020-09-18" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Visual Inference for Graphcial Diagnostic of Linear Mixed Models
### Kaiwen Jin
### Monash University
### 2020-09-18

---


# Linear Mixed Model

- What is a linear mixed model?

   `$$\boldsymbol{y = X\beta + Zb + e}$$`
where 
  - `\(\mathbf{y}\)` is a `\(\mathbf{N \times 1}\)` vector of observations, outcome variable
  - `\(\mathbf{X}\)` is a `\(\mathbf{N \times p}\)` matrix
  - `\(\boldsymbol\beta\)` is a `\(\mathbf{p \times 1}\)` vector of the fixed effect
  - `\(\mathbf{b}\)` is a `\(\mathbf{N \times q}\)` matrix
  - `\(\mathbf{b}\)` is a `\(\mathbf{q \times 1}\)` vector of the random effect
  - `\(E[\mathbf{y}] = \boldsymbol{X\beta}\)` and `\(V(\mathbf{y}) = \mathbf\Omega = \boldsymbol{Z\Gamma Z^\top + R}\)`

- Where and why should we use the linear mixed model?
  - flexible
    
- How can we implement the linear mixed model?
  - `lmer` function from `lme4` package
  - `mmer` function from `sommer` package
  
---

# Visual inference for graphcial diagnostic

- What are the classical statistical inference?
  + t-test, F-test or likelihood ratio - fixed effect
  + AIC, BIC - nested model
  + likelihood ratio test - random effect

- Why we want to use the graphical diagnostic?

  Graphical diagnostic is useful to see when there is a problem with the model and where it occurs, besides, it gives some signs that what could be the reason of the issue.

- How does it works?
  - lineups

---

# Graphical diagnostic on residual analysis

* Types of residuals and corresponding residual diagnostic purpose:

  - Marginal residuals, `\(\boldsymbol{\hat\xi = y - X\hat \beta}\)`
      + Linear of the effects fixed 
      + Presence of outlying observations
      + Within-units covariance matrix 
    
  - Conditional residuals, `\(\boldsymbol{\hat e = y - X\hat \beta - Z\hat b}\)`
      + Presence of outlying observations 
      + Homoskedasticity of conditional errors 
      + Normality of conditional errors 
      
  - Random effect residuals, `\(\mathbf{Z\hat b}\)`
      + Presence of outlying subjects 
      + Normality of the random effects 

---

# Linguistic data




```r
fit_df %&gt;% 
  arrange(scenario) %&gt;% 
  mutate(index = 1:n()) %&gt;% 
  ggplot(aes(index, resc_std, color = scenario)) + 
  geom_point() + 
  geom_hline(yintercept = 0) + 
  scale_color_discrete_qualitative()
```

![](presentation_1_files/figure-html/unnamed-chunk-1-1.svg)&lt;!-- --&gt;

---
# Motivation: Justify the research topic

* define topic

  * What is linear mixed model?



  * Why use the visual inference rather than the classical statistical inference?
    - what are the classical statistical inference?
      + t-test, F-test or likelihood ratio - fixed effect
      + AIC, BIC - nested model
      + likelihood ratio test - random effect
    - parallel

* why would we use the plots to do the diagnostic rather than the classical inference

Although we always using ggplot to do the graph, we never think about the plots can replace the statistical inference.

LME is the new contents for me.

Love coding

* benefits

- what is relevent to topic
- what is not relevent

---

# Objectives - research questions

"Which plot is most different"
---

# Literature review

- your topic is significant
- you understant the topic
- main point: distinguish your research from similar current research

describe significant contributions
analyse the strengths and weaknesses of these contributions
describe how these are relevant to your research
identify how you will extend on the current research; that is your contribution

---

# Purpose of the project plan?

* state the data and the data sources you will use
* outline how you will collect and manage 
* introduce the methodology

---
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
