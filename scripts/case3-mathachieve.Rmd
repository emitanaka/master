---
title: "Case for MathAchieve and MathAchSchool"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(lme4)
library(nlme)
library(dplyr)
library(ggplot2)
library(tidyr)
library(purrr)
library(ggbeeswarm)
library(stringr)
library(colorspace)
library(nullabor)
library(ggforce)
```

Each row in `MathAchieve` represents each of the 7185 students within 160 schools. Each row in `MathAchSchool` represents each of 160 schools.

[http://www.stat.rutgers.edu/home/yhung/Stat586/Mixed%20model/appendix-mixed-models.pdf]

The variables that we are going to use:
- School
- SES
- MathAch
- Sector
- MEANSES

```{r}
data("MathAchieve")
summary(MathAchieve)
```
```{r}
df <- MathAchieve %>% 
  filter(Minority == "No", Sex == "Female")
head(df)
length(unique(df$School))
```

```{r}
data("MathAchSchool")
head(MathAchSchool)
```

```{r}
attach(df)
mses <- tapply(SES, School, mean)
detach(df)
```


```{r}
Bryk <- as.data.frame(df[,c("School", "SES", "MathAch")])
Bryk$meanses <- mses[as.character(Bryk$School)]
Bryk$cses <- Bryk$SES - Bryk$meanses
sector <- MathAchSchool$Sector
names(sector) <- row.names(MathAchSchool)
Bryk$Sector <- sector[as.character(Bryk$School)]
Bryk <- Bryk %>% group_by(School) %>% dplyr::mutate(size = n())
dat <- Bryk %>% filter(size>min(Bryk$size))
length(unique(dat$School))
dat <- dat %>% mutate(Sector = ifelse(Sector == "Public", 0, 1))
colnames(dat)[3] <- c("y")
```

```{r}
testrandom <- plyr::ddply(dat, .(School), function(x) {
  m <- lm(y ~ SES + Sector, data = x)
  data.frame(x, fitted = fitted(m))	
})

ggplot(testrandom, aes(SES+Sector, fitted, group = School)) + geom_line()
```


```{r}
# random intercept and random slope
ma.mod1 <- lmer(y ~ SES + Sector + (SES|School), data = dat)
# independent random effects
ma.mod2 <- lmer(y ~ SES*cses + Sector*cses + (cses -1 |School) + (1|School), data = dat)
#summary(slmod1)
#summary(slmod2)

set.seed(987654321)
ma.mod2.sims  <- simulate(ma.mod2, nsim = 19)
ma.mod2.refit <- lapply(ma.mod2.sims, refit, object = ma.mod2)
ma.mod2.sim.ranef <- lapply(ma.mod2.refit, function(x) ranef(x)[[1]])
ma.mod2.sim.ranef <- do.call("rbind", ma.mod2.sim.ranef)
ma.mod2.sim.ranef$.n <- rownames(ma.mod2.sim.ranef)
ma.mod2.sim.ranef$.n <- as.numeric(str_extract(ma.mod2.sim.ranef$.n, "\\d+"))
true.ma.mod1.ranef <- ranef(ma.mod1)$School
ma_df <- nullabor:::add_true(ma.mod2.sim.ranef, true.ma.mod1.ranef, pos = 9)
ggplot(data = ma_df, aes(x = `(Intercept)`, y = cses)) + 
  geom_point(alpha = 0.4) +
  geom_smooth(method = "lm", se = FALSE, alpha = 0.4) +
  facet_wrap( ~ .sample, ncol=5) + 
  xlab(NULL) + 
  ylab(NULL)
```

Hence, the `mod1` should be used.

```{r fitfn}
extract.fitted.mod <- function(mod, data){
  N <- nrow(data)
  schools <- unique(data$School)
  nschools <- length(schools)

  y <- data$y
  X <- getME(mod, "X")
  beta <- fixef(mod)
  Z <- getME(mod, "Z")
  u <- c(ranef(mod)$School[,1], ranef(mod)$School[,2])
  q <- length(u)

  vc <- as.data.frame(VarCorr(mod))
  R <- vc$vcov[vc$grp == 'Residual'] * diag(N)
  G1 <- vc$vcov[vc$grp == 'School'][1] * diag(nschools)
  G2 <- vc$vcov[vc$grp == 'School'][2] * diag(nschools)
  G <- Matrix::bdiag(G1, G2)
  G[lower.tri(G)] <- vc$vcov[vc$grp == 'School'][3]
  G[upper.tri(G)] <- vc$vcov[vc$grp == 'School'][3]

  Sigma <- Z %*% G %*% t(Z) + R 

  Sigma_inv <- solve(Sigma)

  P <- Sigma_inv - Sigma_inv %*% X %*% vcov(mod) %*% t(X) %*% Sigma_inv

  varMargRes <- Sigma - X %*% vcov(mod) %*% t(X) 
  varCondRes <- R %*% P %*% R  
  varU <- G - G %*% t(Z) %*% P %*% Z %*% G

  fitted_df <- data %>% 
    mutate(
      fitted = as.vector(X %*% beta),
      resm = y - fitted,
      resc = as.vector(y - fitted - Z %*% u),
      index = 1:nrow(data)) %>% 
    mutate(resm_std = resm/sqrt(diag(varMargRes)[index]),
           resc_std = resc/sqrt(diag(varCondRes)[index])) %>% 
    ungroup()
  
  return(fitted_df)
}
```

```{r}
ma.fitted <- extract.fitted.mod(ma.mod1, dat)
```

```{r}
ggplot(ma.fitted, aes(index, resc_std)) + geom_point()
ggplot(ma.fitted, aes(sample = resc_std)) + geom_qq() + geom_qq_line()
```



```{r}
fit_bryk <- Bryk %>% 
  mutate(fitted = as.vector(X %*% beta),
         resm = MathAch - fitted, 
         resc = MathAch - fitted - as.vector(Z %*% u),
         index = 1:n()) %>% 
  rowwise() %>% 
  mutate(resm_std = resm / sqrt(diag(varMargRes)[index]),
         resc_std = resc / sqrt(diag(varCondRes)[index])) %>% 
  ungroup()
```

```{r}
head(fit_bryk)
```


Lesaffre and Verbeke comment that when the within-unit covariance structure is adequate, $V_i = ||I_{m_i} - \varepsilon_i \varepsilon^\top||^2$, where $\varepsilon_i = \hat \Omega ^{-1/2} \hat \xi$ should be close to zero. However, Singer consider replacing $\varepsilon_i$ in $V_i$ with the standardised marginal residuals $\hat \xi_i^* = [\hat V(\hat \xi_i)]^{-1/2} \hat \xi_i$, where $V(\hat \xi_i)$ refers to the diagonal block of $\Omega - X(X^\top \Omega^{-1} X)^{-1} X^\top$ associated to the $i$ unit.

```{r}
unit_df <- expand_grid(school) %>% 
  # cannot follow Vi quit well
  mutate(Vi = map_dbl(school, ~{
    ind <- Bryk %>% 
      mutate(index = 1:n()) %>% 
      filter(School == .x) %>% 
      pull(index)
    mi <- length(ind)
    # standardised marginal residual
    Ei <- solve(expm::sqrtm(varMargRes[ind, ind])) %*% fit_bryk$resm[ind]
    sqrt(sum((diag(mi) - Ei %*% t(Ei))^2)) / mi
  }),
  Mi = as.vector(t(u) %*% solve(varU) %*% u)
  )
```

## Diagnostic Plot 1: Linearity of fixed effects

```{r}
ggplot(fit_bryk, aes(fitted, resm_std)) +
  geom_hline(yintercept = 0) +
  geom_point()
```

## Diagnostic Plot 2: Prescence of outlying observations

```{r}
ggplot(fit_bryk, aes(index, resm_std)) + geom_point() + geom_hline(yintercept = 0)
```

## Diagnostic Plot 3: Within-units covariance matrix

```{r}
ggplot(unit_df, aes(1:nrow(unit_df), Vi)) + geom_point()+ xlab("Unit indicies") + ylab("Modified Lesaffre-Verbeke index")
```

## Diagnostic Plot 4: Prescense of outlying observations using conditional residual

```{r}
ggplot(fit_bryk, aes(index, resc_std)) + geom_point() + geom_hline(yintercept = 0)
```

## Diagnostic Plot 5: Homoskedasticity of conditional errors 

```{r}
ggplot(fit_bryk, aes(fitted, resc_std)) + geom_point() + geom_hline(yintercept = 0)
```

## Diagnostic Plot 6: Normality of conditional errors

```{r}
ggplot(fit_bryk, aes(sample = resc_std)) + 
  geom_qq() + geom_qq_line(color = "red")
```

## Diagnostic Plot 7: Presencse of outlying subjects 

```{r}
ggplot(unit_df, aes(1:nrow(unit_df), Mi)) + geom_point() + xlab("Unit index") + ylab("Manhalanobis distance")
```

## Diagnostic Plot 8: Normality of the random effects

```{r}
ggplot(unit_df, aes(sample = Mi)) + 
  geom_qq(distribution = stats::qchisq,
          dparams = list(df = q)) +
  geom_qq_line(color = "red",
               distribution = stats::qchisq,
               dparams = list(df = q))
```

```{r}
d <- lineup(null_permute("MathAch"), Bryk, pos = 1)
```

```{r}
simdat <- purrr::map_dfr(1:20, function(i){
  df <- d %>% filter(.sample == i)
  m <- lmer(MathAch ~ SES + Sector + Minority + Sex + (1|School), data = df)
  
  N <- nrow(df)
  y <-  df$MathAch
  X <- model.matrix(~ SES + Sector + Minority + Sex, data = df)
  beta <- fixef(m)
  Z <- model.matrix(~ School - 1, data = df)
  u <- ranef(m)$School[,1]
  q <- length(u)
  vc <- as.data.frame(VarCorr(m))
  R <- vc$vcov[vc$grp == "Residual"] * diag(N)
  G <- vc$vcov[vc$grp == "School"] * diag(q)
  Sigma <- Z %*% G %*% t(Z) + R
  Sigma_inv <- solve(Sigma)
  varMargRes <- Sigma - X %*% solve(t(X) %*% solve(Sigma) %*% X) %*% t(X)
  P <- Sigma_inv - Sigma_inv %*% X %*% solve(t(X) %*% Sigma_inv %*% X) %*% t(X) %*% Sigma_inv
  varCondRes <- R %*% P %*% R
  varU <- G - G %*% t(Z) %*% P %*% Z %*% G
  
  fitted = as.vector(X %*% beta)
  resm = y - fitted
  resc = y - fitted - as.vector(Z %*% u)
  index = 1:nrow(df)
  resm_std = resm / sqrt(diag(varMargRes)[index])
  resc_std = resc / sqrt(diag(varCondRes)[index])
  
  tibble::tibble(df, fitted, resm_std, resc_std, index)
})
```

```{r}
df <- d %>% filter(.sample == 2)
m <- lmer(MathAch ~ SES + Sector + Minority + Sex + (1|School), data = df)

N <- nrow(df)
y <-  df$MathAch
X <- model.matrix(~ SES + Sector + Minority + Sex, data = df)
beta <- fixef(m)
Z <- model.matrix(~ School - 1, data = df)
u <- ranef(m)$School[,1]
q <- length(u)
vc <- as.data.frame(VarCorr(m))
R <- vc$vcov[vc$grp == "Residual"] * diag(N)
G <- vc$vcov[vc$grp == "School"] * diag(q)
Sigma <- Z %*% G %*% t(Z) + R
Sigma_inv <- solve(Sigma)
varMargRes <- Sigma - X %*% solve(t(X) %*% solve(Sigma) %*% X) %*% t(X)
P <- Sigma_inv - Sigma_inv %*% X %*% solve(t(X) %*% Sigma_inv %*% X) %*% t(X) %*% Sigma_inv
varCondRes <- R %*% P %*% R
varU <- G - G %*% t(Z) %*% P %*% Z %*% G
  
fitted = as.vector(X %*% beta)
resm = y - fitted
resc = y - fitted - as.vector(Z %*% u)
index = 1:nrow(df)
resm_std = resm / sqrt(diag(varMargRes)[index])
resc_std = resc / sqrt(diag(varCondRes)[index])
```


```{r}
fit.sim  <- simulate(fit, nsim = 19, seed = 1234)
fit.refit <- lapply(fit.sim, refit, object = fit)
fit.simy <- lapply(fit.refit, function(x) getME(x, "y"))
```

```{r}
fit.sim.y <- do.call("cbind", fit.simy)
fit.sim.y <- reshape2::melt(fit.sim.y)[-1]
names(fit.sim.y) <- c(".n", "y")
fit.sim.y$.n <- as.numeric(str_extract(fit.sim.y$.n, "\\d+"))
fit.sim.y$School <- rep(Bryk$School, 19)
fit.sim.y$SES <- rep(Bryk$SES, 19)
fit.sim.y$Sector <- rep(Bryk$Sector, 19)
```
